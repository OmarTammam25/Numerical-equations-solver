[1mdiff --git a/LU/LUCrout.py b/LU/LUCrout.py[m
[1mindex ffacab3..8b19e3e 100644[m
[1m--- a/LU/LUCrout.py[m
[1m+++ b/LU/LUCrout.py[m
[36m@@ -1,22 +1,27 @@[m
[31m-import numpy as np[m
 import math[m
[32m+[m[32mimport timeit[m
[32m+[m
 [m
 class LU_Crout:[m
 [m
     def IsSingular(self, A, s, o, k, tol):[m
[31m-        if ((abs(A[o[k]][k]) / float(s[o[k]])) < tol): return True[m
[32m+[m[32m        if ((abs(A[o[k]][k]) / s[o[k]]) < tol): return True[m
         return False[m
 [m
[31m-    def Crout(self, A, b, X, tol, er=0):[m
[32m+[m[32m    def Crout(self, A, b, X, tol, sig=2, er=0):[m
[32m+[m[32m        startTime = timeit.default_timer()[m
         n = len(A)[m
         o = [0] * n[m
         s = [0] * n[m
 [m
[31m-        self.Decompose(A, tol, o, s)[m
[31m-        if er == -1: return[m
[31m-        self.Substitute(A, o, n, b, X)[m
[32m+[m[32m        self.Decompose(A, tol, o, s, sig)[m
[32m+[m[32m        if (er == -1): return[m
[32m+[m[32m        self.Substitute(A, o, n, b, X, sig)[m
[32m+[m[32m        endTime = timeit.default_timer()[m
[32m+[m[32m        time = endTime - startTime[m
[32m+[m[32m        print(round(time * 10 ** 3, 5), "ms")[m
 [m
[31m-    def Decompose(self, A, tol, o, s, er=0):[m
[32m+[m[32m    def Decompose(self, A, tol, o, s, sig, er=0):[m
 [m
         n = len(A)[m
 [m
[36m@@ -25,70 +30,77 @@[m [mclass LU_Crout:[m
             s[i] = abs(A[i][0])[m
 [m
             for j in range(1, n):[m
[31m-                if abs(A[i][j] > s[i]):[m
[32m+[m[32m                if (abs(A[i][j] > s[i])):[m
                     s[i] = abs(A[i][j])[m
 [m
         for i in range(0, n):[m
             self.Pivot(A, o, s, n, i)[m
 [m
[31m-            if self.IsSingular(A, s, o, i, tol):[m
[32m+[m[32m            if (self.IsSingular(A, s, o, i, tol)):[m
                 er = -1[m
                 return[m
 [m
             for j in range(i, n):[m
 [m
[31m-                for k in range(0, i): A[o[j]][i] -= A[o[j]][k] * A[o[k]][i][m
[32m+[m[32m                for k in range(0, i): A[o[j]][i] = self.round_sig(A[o[j]][i], sig) - self.round_sig(A[o[j]][k],[m
[32m+[m[32m                                                                                                    sig) * self.round_sig([m
[32m+[m[32m                    A[o[k]][i], sig)[m
 [m
             for j in range(i, n):[m
 [m
                 if i == j: continue[m
 [m
[31m-                for k in range(0, i): A[o[i]][j] -= A[o[i]][k] * A[o[k]][j][m
[32m+[m[32m                for k in range(0, i): A[o[i]][j] = self.round_sig(A[o[i]][j], sig) - self.round_sig(A[o[i]][k],[m
[32m+[m[32m                                                                                                    sig) * self.round_sig([m
[32m+[m[32m                    A[o[k]][j], sig)[m
 [m
[31m-                if A[o[i]][i] == 0:[m
[32m+[m[32m                if (A[o[i]][i] == 0):[m
                     er = -1[m
                     return[m
 [m
[31m-                A[o[i]][j] /= float(A[o[i]][i])[m
[32m+[m[32m                A[o[i]][j] = self.round_sig(A[o[i]][j], sig) / self.round_sig(A[o[i]][i], sig)[m
 [m
     def Pivot(self, a, o, s, n, k):[m
         p = k[m
         big = abs(a[o[k]][k]) / s[o[k]][m
         for i in range(k + 1, n):[m
             dummy = abs(a[o[i]][k]) / s[o[i]][m
[31m-            if dummy > big:[m
[32m+[m[32m            if (dummy > big):[m
                 big = dummy[m
                 p = i[m
         dummy = o[p][m
         o[p] = o[k][m
         o[k] = dummy[m
 [m
[31m-    def ForwardSubstitution(self, A, o, n, b):[m
[32m+[m[32m    def ForwardSubstitution(self, A, o, n, b, sig):[m
         y = [0] * n[m
         for i in range(0, n):[m
             y[o[i]] = b[o[i]][m
[32m+[m[32m            for j in range(0, i): y[o[i]] = self.round_sig(y[o[i]], sig) - self.round_sig(A[o[i]][j],[m
[32m+[m[32m                                                                                          sig) * self.round_sig(y[o[j]],[m
[32m+[m[32m                                                                                                                sig)[m
 [m
[31m-            for j in range(0, i): y[o[i]] -= A[o[i]][j] * y[o[j]][m
[31m-[m
[31m-            y[o[i]] /= float(A[o[i]][i])[m
[32m+[m[32m            y[o[i]] = self.round_sig(y[o[i]], sig) / self.round_sig(A[o[i]][i], sig)[m
         return y[m
 [m
[31m-    def BackwardSubtitution(self, A, X, o, n, y):[m
[32m+[m[32m    def BackwardSubtitution(self, A, X, o, n, y, sig):[m
 [m
[31m-        X[n - 1] = y[o[n - 1]][m
[32m+[m[32m        X[n - 1] = self.round_sig(y[o[n - 1]], sig)[m
         for i in range(n - 2, -1, -1):[m
[31m-            X[i] = y[o[i]][m
[32m+[m[32m            X[i] = self.round_sig(y[o[i]], sig)[m
 [m
[31m-            for j in range(n - 1, i, -1):[m
[31m-                X[i] -= A[o[i]][j] * X[j][m
[32m+[m[32m            for j in range(n - 1, i, -1): X[i] = self.round_sig(X[i], sig) - self.round_sig(A[o[i]][j],[m
[32m+[m[32m                                                                                            sig) * self.round_sig(X[j],[m
[32m+[m[32m                                                                                                                  sig)[m
 [m
[31m-    def Substitute(self, A, o, n, b, X):[m
[31m-        y = self.ForwardSubstitution(A, o, n, b)[m
[31m-        self.BackwardSubtitution(A, X, o, n, y)[m
[32m+[m[32m    def Substitute(self, A, o, n, b, X, sig):[m
[32m+[m[32m        y = self.ForwardSubstitution(A, o, n, b, sig)[m
[32m+[m[32m        self.BackwardSubtitution(A, X, o, n, y, sig)[m
 [m
     def round_sig(self, x, sig=2):[m
[31m-        if x==0:[m
[32m+[m[32m        if x == 0:[m
             return 0[m
[31m-        if sig==-1:[m
[32m+[m[32m        if sig == -1:[m
             return x[m
[31m-        return round(x,sig-int(math.floor(math.log10(abs(x))))-1)[m
\ No newline at end of file[m
[32m+[m[32m        return round(x, sig - int(math.floor(math.log10(abs(x)))) - 1)[m
[41m+[m
[1mdiff --git a/LU/LUDoolittle.py b/LU/LUDoolittle.py[m
[1mindex 6f20867..51ad047 100644[m
[1m--- a/LU/LUDoolittle.py[m
[1m+++ b/LU/LUDoolittle.py[m
[36m@@ -1,12 +1,17 @@[m
[32m+[m[32mimport timeit[m
 import math[m
 class LU_Doolittle():[m
     def execute(self, a, b, n, x, tol, seg, er=0):[m
[32m+[m[32m        startTime = timeit.default_timer()[m
         s = [0] * n[m
         o = [0] * n[m
         er = 0[m
         self.Decompose(a, n, tol, o, s, seg, er)[m
         if er != -1:[m
             self.Substitute(a, o, n, b, x,seg)[m
[32m+[m[32m        endTime = timeit.default_timer()[m
[32m+[m[32m        time = endTime - startTime[m
[32m+[m[32m        print(round(time * 10 ** 3, 5), "ms")[m
 [m
     def Decompose(self, a, n, tol, o, s, seg, er):[m
         for i in range(0, n):[m
[1mdiff --git a/LU/__pycache__/LUCrout.cpython-310.pyc b/LU/__pycache__/LUCrout.cpython-310.pyc[m
[1mindex 7d0ffc2..e314527 100644[m
Binary files a/LU/__pycache__/LUCrout.cpython-310.pyc and b/LU/__pycache__/LUCrout.cpython-310.pyc differ
[1mdiff --git a/LU/__pycache__/LUDoolittle.cpython-310.pyc b/LU/__pycache__/LUDoolittle.cpython-310.pyc[m
[1mindex fe7dbc3..0ab786f 100644[m
Binary files a/LU/__pycache__/LUDoolittle.cpython-310.pyc and b/LU/__pycache__/LUDoolittle.cpython-310.pyc differ
[1mdiff --git a/LU/__pycache__/cholesky.cpython-310.pyc b/LU/__pycache__/cholesky.cpython-310.pyc[m
[1mindex abf3f7c..9a82627 100644[m
Binary files a/LU/__pycache__/cholesky.cpython-310.pyc and b/LU/__pycache__/cholesky.cpython-310.pyc differ
[1mdiff --git a/LU/cholesky.py b/LU/cholesky.py[m
[1mindex 5c77767..4f2524d 100644[m
[1m--- a/LU/cholesky.py[m
[1m+++ b/LU/cholesky.py[m
[36m@@ -1,13 +1,20 @@[m
 import math[m
[32m+[m[32mimport timeit[m
[32m+[m
[32m+[m[32mfrom numpy.linalg import linalg[m
 [m
 [m
 class LU_cholesky():[m
     def execute(self, a, b, n, x, tol,seg,er=0):[m
         self.check_syemetric(a, n, er)[m
[32m+[m[32m        self.check_eigenValues(a, er)[m
[32m+[m[32m        startTime = timeit.default_timer()[m
         self.Decompose(a, n, tol, seg,er)[m
         if er != -1:[m
             self.Substitute(a, n, b, x,seg)[m
[31m-[m
[32m+[m[32m        endTime = timeit.default_timer()[m
[32m+[m[32m        time = endTime - startTime[m
[32m+[m[32m        print(round(time * 10 ** 3, 5), "ms")[m
     def Decompose(self, a, n, tol,seg, er):[m
         # TODO check if it is symmetric and update the er[m
         l = [[0 for x in range(n)][m
[36m@@ -56,4 +63,10 @@[m [mclass LU_cholesky():[m
             return 0[m
         if sig==-1:[m
             return x[m
[31m-        return round(x,sig-int(math.floor(math.log10(abs(x))))-1)[m
\ No newline at end of file[m
[32m+[m[32m        return round(x,sig-int(math.floor(math.log10(abs(x))))-1)[m
[32m+[m
[32m+[m[32m    def check_eigenValues(self,a,er):[m
[32m+[m[32m        eigenValues = linalg.eigvals(a)[m
[32m+[m[32m        for i in eigenValues:[m
[32m+[m[32m            if i<0:[m
[32m+[m[32m                re = -1[m
[1mdiff --git a/LU/test.py b/LU/test.py[m
[1mindex 1482dd6..fd8e916 100644[m
[1m--- a/LU/test.py[m
[1m+++ b/LU/test.py[m
[36m@@ -19,7 +19,7 @@[m [mif __name__ == '__main__':[m
          [55, 225, 979]][m
     b = [76, 295, 1259][m
     x = [0, 0, 0][m
[31m-    crout.Crout(a,b,x,0.00001,er)[m
[32m+[m[32m    crout.Crout(a,b,x,0.00001,9,er)[m
     print("crout",x)[m
     a = [[6, 15, 55],[m
          [15, 55, 225],[m
